import numpy as np

#数组属性
arr = [[1., 0., 0.],
       [0., 1., 2.]]

  # 数组轴的个数
arr.ndim
# 数组维度及长度，例如2×3的数组其shape为(2, 3)
arr.shape
# 数组元素的总个数
arr.size
# 数组中元素的数据类型
arr.dtype
# 数组中元素所占字节数
arr.itemsize

 # 普通数组转化为numpy数组
a1 = np.array([2, 3, 4], dtype=float)
print(a1)
# 将元组数组转化为二维numpy数组
a2 = np.array([(1, 2, 3), (3, 4, 5)])
print(a2)
# 将3×3的数组用1填充
a3 = np.ones((3, 3))
print(a3)
# 从1到10，每隔2生成一个元素
a4 = np.arange(1, 10, 2)
print(a4)
# 在1到12之间生成4个元素
a5 = np.linspace(1, 12, 4, dtype=int)
print(a5)
# 生成指定维度的随机数组
print(np.random.rand(1, 5))
# 在指定区间生成随机浮点数
print(np.random.uniform(low=1, high=2, size=5))
# 在指定区间生成随机浮点数
print(np.random.randint(low=1, high=10, size=5))
# 使用相同的种子产生随机数
np.random.seed(666)
print(np.random.rand(5))
np.random.seed(666)  # 每次产生前都要设置
print(np.random.rand(5))

##普通数组转化为numpy对象：
#  [2. 3. 4.]
#  元组数组：
#  [[1 2 3]
#   [3 4 5]]
#  用1填充数组：
#  [[1. 1. 1.]
#   [1. 1. 1.]
#   [1. 1. 1.]]
#  从1到10每隔2生成一个元素：
#  [1 3 5 7 9]
#  在1到12之间生成4个元素：
#  [ 1  4  8 12]
#  生成(1, 5)浮点数组
#  [[0.73483009 0.42395071 0.03067476 0.87905934 0.3825438 ]]
#  在[1,2)产生5个随机浮点数数
#	[1.73563967 1.20877954 1.59162307 1.1021683  1.29736842]
#	在[1,10)产生5个随机整数
#	[6 5 3 6 8]
#	相同的随机数
#	[0.70043712 0.84418664 0.67651434 0.72785806 0.95145796]
#	[0.70043712 0.84418664 0.67651434 0.72785806 0.95145796]

#创建数组
A = np.array([[1, 1],
              [0, 1]])
B = np.array([[2, 0],
              [3, 4]])
print(A * B)
print(A @ B)

#'''
#矩阵元素对应相乘：
#[[2 0]
# [0 4]]
#矩阵的乘法：
#[[5 4]
# [3 4]]
#'''

#数组运算
a = np.array([[0, 1, 2, 3],
              [4, 5, 6, 7],
              [8, 9, 10, 11]])
print(a.max())  # 求整体的最大值，结果为11
print(a.sum(axis=0))  # 求每一列的和，结果为：[12 15 18 21]
print(np.sqrt(a))   # 数组每个元素求开方

#获取元素
b = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
print(b[1:3])  # 输出下标为1到3的元素：[1 2]
print(b[::-2])  # 逆序每隔两个元素选一个值：[9 7 5 3 1]

c = np.array([[0, 1, 2, 3],
              [10, 11, 12, 13],
              [40, 41, 42, 43]])
# 输出a第一维(行)的前三个，第二维(列)下标的1~3
print(c[1:3, 0:3])
# 输出行的所有，下标为2的列
print(c[2, ...])
# 遍历数组
for row in c:
    print(row)
# 遍历每个子元素
for item in c.flat:
    print(item)

#'''
#后两行的1~3列：
#[[10 11 12]
# [40 41 42]]
#第三行的所有列：
#[40 41 42 43]
#遍历数组：
#[0 1 2 3]
#[10 11 12 13]
#[40 41 42 43]
#遍历每个元素：
#0
#1
#2
#......
#41
#42
#43
#'''

a = np.arange(12) ** 2
print(a)
i = np.array([1, 3, 5])
print(a[i])
# 多维数组索引j
j = np.array([[3, 4], [9, 7]])
print(a[j])

'''
[  0   1   4   9  16  25  36  49  64  81 100 121]
数组a的1、3、5个元素
[ 1  9 25]
通过多为索引j取出a的数据填到对应位置
[[ 9 16]
 [81 49]]
'''

 #a = np.array([[0, 1, 2, 3],
 #                  [4, 5, 6, 7],
 #                  [8, 9, 10, 11]])
 #a = np.array(([[0, 1, 2, 3],
 #              [4, 5, 6, 7],
 #              [8, 9, 10, 11]]))

# 对a的第一个维度进行选择
i = np.array([0, 1])
print(a[i])
# 对数组a在多个维度上进行选择，同时提供i,j代表取出a的[0,2]、[1,3]两个元素
j = np.array([2, 3])
print(a[i, j])
  ## '''
  # 选择多维数组a的第0、1两行：
  # [[0 1 2 3]
  #  [4 5 6 7]]
  # a的[0,2]、[1,3]两个元素：
  # [2 7]
  # '''

mask = np.array([[True, False],
                 [True, True]])
padded = np.zeros((2, 2))
padded[mask] = np.array([1, 2, 3])  # 用序列填充被mask选中的位置
print(padded)
#'''
#[[1. 0.]
# [2. 3.]]
#'''

#改变维度

a=np.array([[1,2,3,4,5,6],
                [7,8,9,10,11,12]])
b=a.reshape(3,4)
print(b)
# 多维数组，自动计算
print(a.reshape(-1,3,2))
# 展开数组
flatted = b.ravel()
print(flatted, end=' ')
   #'''
   #[[ 1  2  3  4]
   # [ 5  6  7  8]
   # [ 9 10 11 12]]
   #2×3×2的多维数组：
   #[[[ 1  2]
   #  [ 3  4]
   #  [ 5  6]]
   # [[ 7  8]
   #  [ 9 10]
   #  [11 12]]]
   #展开数组：
   #[ 1  2  3  4  5  6  7  8  9 10 11 12]
   ##'''

##a = np.array([
#       [[1, 2, 3, 4],
#        [5, 6, 7, 8],
#        [9, 10, 11, 12]],
#       [[13, 14, 15, 16],
#        [17, 18, 19, 20],
#        [21, 22, 23, 24]]
#   ])
b = a.transpose(2, 0, 1)
print(b)
   #'''
   #[[[ 1  5  9]
   #  [13 17 21]]
   # [[ 2  6 10]
   #  [14 18 22]]
   # [[ 3  7 11]
   #  [15 19 23]]
   # [[ 4  8 12]
   #  [16 20 24]]]
   #'''

#数组的合并

a1 = np.array([[1, 3], [5, 7]])
a2 = np.array([[2, 4], [6, 8]])
a3 = np.concatenate((a1, a2))  # 合并数组
print(a3)
print(np.concatenate((a1, a2), axis=1))  # 指定合并的轴
'''
[[1 3]
 [5 7]
 [2 4]
 [6 8]]
[[1 3 2 4]
 [5 7 6 8]]
'''

a=np.array([1,2,3])
b=np.array([4,5,6])
# 垂直方向合并
c=np.vstack((a,b))
print(c)
# 水平方向合并
print(np.hstack((a,b)))
# 水平方向拆分
print(np.hsplit(c,3))
'''
垂直堆叠
[[1 2 3]
 [4 5 6]]
水平合并
[1 2 3 4 5 6]
水平拆分为三个1×2的：
[array([[1],
       [4]]), 
array([[2],
       [5]]), 
array([[3],
       [6]])]
'''

#数组的复制

a = np.array([1, 2, 3])
b = a
# 修改b
b[0] = 0
print(a)
# 输出a、b对象的id
print(id(a), id(b))

'''
修改b，a也发生了变化
[0 2 3]
查看二者的id
2290013812656 2290013812656
'''

c = a[:]
# 修改视图的形状
c.shape = 3, 1
print(c, a)
# 修改视图c的数据
c[0] = 1
print(a[0])

'''
对视图c的形状做修改，a不会受到影响
[[0]
 [2]
 [3]] [0 2 3]
修改c的数据，a也会随之改变：
1
'''

d = a.copy()
d[0] = 5
# 修改数组的副本d，a不受影响，输出a：[1 2 3]
print(a)

#保存文件

np.save("output.npy", arr)

arr = np.load("output.npy", allow_pickle=True)

np.savez('array_save.npz', arr1, arr2, arr3)

Arr = np.load('arr_save.npz')
arr1 = Arr['arr1']  # 通过key值取到不同数组

np.savetxt('data.txt', arr)

data = np.loadtxt('data.txt')

#在保存文件时可以通过fmt属性设置输出数组的格式，如下设置保存数据为整型，且后跟一个制表符
np.savetxt("./output.txt", data, fmt='%d	')





